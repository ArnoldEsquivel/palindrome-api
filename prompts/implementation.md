# üìã PLAN DE IMPLEMENTACI√ìN DETALLADO - RETO PAL√çNDROMO

## üéØ OBJETIVO
Implementar exactamente el backend del "Reto Pal√≠ndromo" seg√∫n especificaciones del Architecture.md, sin agregar funcionalidades adicionales.

## üèóÔ∏è ARQUITECTURA Y PATRONES

### Patrones Principales:
- **Module Pattern**: Organizaci√≥n por dominio (core, modules)
- **Service Pattern**: L√≥gica de negocio encapsulada
- **Patr√≥n est√°ndar NestJS con TypeORM**: Inyecci√≥n directa de Repository en Service
- **Dependency Injection**: Inyecci√≥n de dependencias de NestJS
- **DTO Pattern**: Objetos de transferencia de datos con validaci√≥n

### üéØ DECISIONES ARQUITECT√ìNICAS FUNDAMENTADAS:

#### 1. **Repository Pattern vs Est√°ndar NestJS**
**DECISI√ìN**: Usar patr√≥n est√°ndar de NestJS (inyectar Repository directamente)
**JUSTIFICACI√ìN**: 
- Para un MVP con l√≥gica simple, el patr√≥n est√°ndar es m√°s directo y menos verboso
- TypeORM Repository ya abstrae el acceso a datos suficientemente
- Reduce boilerplate innecesario para consultas b√°sicas
- NestJS est√° dise√±ado para funcionar √≥ptimamente con inyecci√≥n directa de repositorios
- Para futuras mejoras se puede refactorizar a Repository Pattern expl√≠cito si se requiere l√≥gica de datos m√°s compleja

#### 2. **Validaci√≥n con class-validator**
**DECISI√ìN**: Implementar class-validator con naming descriptivo
**JUSTIFICACI√ìN**:
- Validaci√≥n robusta y consistente con el ecosistema NestJS
- Mejor experiencia del desarrollador con decoradores declarativos
- Manejo autom√°tico de errores de validaci√≥n
- Cambiar `q` por `searchTerm` para mayor claridad sem√°ntica

#### 3. **Manejo completo de errores HTTP**
**DECISI√ìN**: Mapear todos los casos con c√≥digos HTTP apropiados
**JUSTIFICACI√ìN**:
- 400 Bad Request para par√°metros faltantes o inv√°lidos
- 200 OK para b√∫squedas v√°lidas (incluso sin resultados)
- Mejor experiencia del cliente API con c√≥digos sem√°nticamente correctos

#### 4. **Seeds integradas en bootstrap**
**DECISI√ìN**: Auto-seeding en bootstrap con flag de entorno
**JUSTIFICACI√ìN**:
- Una sola ejecuci√≥n (`docker compose up`) para revisar la prueba
- Separaci√≥n clara de responsabilidades en archivos dedicados
- Control mediante variable de entorno `AUTO_SEED=true`
- Evita pasos manuales adicionales para el evaluador

#### 5. **Estructura de respuesta enriquecida**
**DECISI√ìN**: `originalPrice`, `finalPrice` y `discountPercentage`
**JUSTIFICACI√ìN**:
- Mejor UX mostrando el descuento expl√≠citamente
- Transparencia total para el usuario final
- Facilita implementaci√≥n de UI que destaque ahorros
- Informaci√≥n completa para analytics de descuentos

#### 6. **B√∫squeda case-insensitive**
**DECISI√ìN**: Case-insensitive para t√≠tulo exacto
**JUSTIFICACI√ìN**:
- Mejor experiencia de usuario (no frustrante por may√∫sculas/min√∫sculas)
- Comportamiento esperado en aplicaciones modernas
- Mantiene la l√≥gica de "exacto" pero m√°s usable
- Consistente con motores de b√∫squeda est√°ndar

### Estructura de Carpetas Actual:
```
src/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ config/           # Configuraci√≥n centralizada (factory pattern + Joi)
‚îÇ   ‚îî‚îÄ‚îÄ database/         # Conexi√≥n DB + seeds
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ products/        # Entidad + servicios de productos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/    # Product entity
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/    # ProductsService
‚îÇ   ‚îî‚îÄ‚îÄ search/          # Endpoint de b√∫squeda
‚îÇ       ‚îú‚îÄ‚îÄ controllers/ # SearchController  
‚îÇ       ‚îú‚îÄ‚îÄ dto/         # DTOs de request/response
‚îÇ       ‚îî‚îÄ‚îÄ services/    # SearchService
‚îú‚îÄ‚îÄ utils/               # PalindromeService (utilidades independientes)
‚îú‚îÄ‚îÄ app.module.ts
‚îî‚îÄ‚îÄ main.ts
```

---

## üöÄ FASE 1: SCAFFOLD DEL PROYECTO

### 1.1 Crear Proyecto NestJS
```bash
# Navegar al directorio back
cd "/Users/arnold/Documents/Proyectos/Acueducto/Reto Palindromo/back"

# Crear proyecto (sobrescribir si existe)
npx @nestjs/cli new palindrome-api --package-manager npm

# Navegar al proyecto
cd palindrome-api
```

### 1.2 Dependencias Instaladas
```bash
# Dependencias de producci√≥n instaladas
npm install @nestjs/typeorm typeorm pg @nestjs/config class-validator class-transformer joi

# Dependencias de desarrollo instaladas
npm install -D @types/pg @types/joi
```

### 1.3 Estructura de Carpetas Creada
```bash
# Estructura core implementada
src/core/config/         # ‚úÖ Configuraci√≥n con factory pattern
src/core/database/       # ‚úÖ Database module + seeds
src/core/database/seeds/ # ‚úÖ Products seeds

# Estructura modules implementada  
src/modules/products/entities/   # ‚úÖ Product entity
src/modules/products/services/   # ‚úÖ ProductsService
src/modules/search/controllers/  # ‚úÖ SearchController
src/modules/search/dto/          # ‚úÖ DTOs
src/modules/search/services/     # ‚úÖ SearchService

# Utilidades implementadas
src/utils/               # ‚úÖ PalindromeService
```

---

## üîß FASE 2: CORE/CONFIG MODULE ‚úÖ IMPLEMENTADO

### 2.1 ConfigModule Implementado
**ESTADO**: ‚úÖ Completamente implementado con factory pattern y validaci√≥n Joi

### 2.2 Config Factory Implementado
**Archivo: `src/core/config/config.factory.ts`** ‚úÖ
```typescript
import { registerAs } from '@nestjs/config';

export default registerAs('config', () => ({
  server: {
    port: parseInt(process.env.PORT, 10) || 3000,
    corsOrigin: process.env.CORS_ORIGIN,
  },
  database: {
    url: process.env.DATABASE_URL,
  },
  app: {
    autoSeed: process.env.AUTO_SEED === 'true',
  },
}));
```

### 2.3 Schema de Validaci√≥n Implementado
**Archivo: `src/core/config/config.schema.ts`** ‚úÖ
```typescript
import * as Joi from 'joi';

export const validationSchema = Joi.object({
  PORT: Joi.number().default(3000),
  CORS_ORIGIN: Joi.string().optional(),
  DATABASE_URL: Joi.string().required(),
  AUTO_SEED: Joi.boolean().default(false),
});
```

### 2.4 Environments Configuration ‚úÖ
**Archivo: `src/core/config/environments.ts`**
```typescript
export const environments = {
  development: '.env.dev',
  production: '.env.prod',
  test: '.env.test',
};
```

### 2.5 Archivo .env Creado ‚úÖ
**Archivo: `.env.dev`**
```env
# Servidor
PORT=3000
CORS_ORIGIN=http://localhost:3001

# Base de datos  
DATABASE_URL=postgresql://postgres:postgres@db:5432/store

# Seeds autom√°ticas en bootstrap (para facilitar evaluaci√≥n)
AUTO_SEED=true
```

---

## üóÑÔ∏è FASE 3: CORE/DATABASE MODULE ‚úÖ IMPLEMENTADO

### 3.1 DatabaseModule Implementado ‚úÖ
**ESTADO**: ‚úÖ Completamente implementado con TypeORM y factory pattern

### 3.2 Entidad Product Implementada ‚úÖ
**Archivo: `src/modules/products/entities/product.entity.ts`**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('products')
export class Product {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'text', unique: true })
  title: string;

  @Column({ type: 'text' })
  brand: string;

  @Column({ type: 'text' })
  description: string;

  @Column({ type: 'numeric', precision: 10, scale: 2 })
  price: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}
```

### 3.3 DatabaseModule Configurado ‚úÖ
**Archivo: `src/core/database/database.module.ts`**
```typescript
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigType } from '@nestjs/config';
import { Module } from '@nestjs/common';

import { Product } from '../../modules/products/entities/product.entity';
import config from '../config/config.factory';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: (configService: ConfigType<typeof config>) => ({
        type: 'postgres',
        url: configService.database.url,
        entities: [Product],
        synchronize: true, // Solo por fines pr√°cticos de esta prueba
        logging: false,
      }),
    }),
    TypeOrmModule.forFeature([Product]),
  ],
  exports: [TypeOrmModule],
})
export class DatabaseModule {}
```

### 3.4 Scripts de Seeds Implementados ‚úÖ
**Archivo: `src/core/database/seeds/seed.ts`**
```typescript
import { DataSource } from 'typeorm';

import { Product } from '../../../modules/products/entities/product.entity';
import { seedProducts } from './products.seeds';

export async function runSeed(dataSource: DataSource) {
  const productRepository = dataSource.getRepository(Product);
  
  // Limpiar datos existentes
  await productRepository.clear();
  
  // Insertar seeds
  for (const productData of seedProducts) {
    const product = productRepository.create(productData);
    await productRepository.save(product);
  }

  console.log('Seeds inserted successfully, now you can try to find some palindromes to get a discount!');
}
```

**Archivo: `src/core/database/seeds/products.seeds.ts`** ‚úÖ
- Contiene +100 productos de muestra incluyendo pal√≠ndromos como 'abba', 'ABBA Pro', etc.

---

## üìù FASE 4: UTILS/PALINDROME MODULE ‚úÖ IMPLEMENTADO

### 4.1 PalindromeService Implementado ‚úÖ
**ESTADO**: ‚úÖ Servicio implementado en `src/utils/palindrome.service.ts`

### 4.2 PalindromeService
**Archivo: `src/utils/palindrome.service.ts`** ‚úÖ
```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class PalindromeService {
    
  /**
   * Normaliza texto para evaluaci√≥n de pal√≠ndromo:
   * - Convierte a min√∫sculas
   * - Remueve diacr√≠ticos
   * - Mantiene solo caracteres alfanum√©ricos [a-z0-9]
   */
  normalizeForPalindrome(text: string): string {
    if (!text) return '';
    
    return text
      .toLowerCase()
      .normalize('NFD')                // Descompone caracteres con acentos
      .replace(/[\u0300-\u036f]/g, '') // Remueve marcas diacr√≠ticas
      .replace(/[^a-z0-9]/g, '');      // Solo alfanum√©rico
  }

  // Eval√∫a si un texto es pal√≠ndromo despu√©s de normalizaci√≥n
  isPalindrome(text: string): boolean {
    const normalized = this.normalizeForPalindrome(text);
    if (normalized.length === 0) return false;
    
    return normalized === normalized.split('').reverse().join('');
  }
}
```

**NOTA**: El PalindromeService est√° ubicado en `src/utils/` en lugar de `src/core/text/` como propone la documentaci√≥n original. Esta es la estructura actual del proyecto.

---

## üõçÔ∏è FASE 5: PRODUCTS MODULE ‚úÖ IMPLEMENTADO

### 5.1 ProductsModule Implementado ‚úÖ
**ESTADO**: ‚úÖ M√≥dulo completamente implementado con entidad y servicio

### 5.2 ProductsService Implementado ‚úÖ
**Archivo: `src/modules/products/services/products.service.ts`**
```typescript
import { InjectRepository } from '@nestjs/typeorm';
import { Injectable } from '@nestjs/common';
import { Repository } from 'typeorm';

import { Product } from '../entities/product.entity';

@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private productRepository: Repository<Product>,
  ) {}

  // Busca producto por t√≠tulo exacto (case-insensitive permitido)
  async findByExactTitle(title: string): Promise<Product | null> {
    if (!title?.trim()) return null;
    
    return this.productRepository
      .createQueryBuilder('product')
      .where('LOWER(product.title) = LOWER(:title)', { title: title.trim() })
      .getOne();
  }

  /**
   * Busca productos donde brand o description contengan el texto
   * Solo se debe llamar si query.length > 3
   */
  async searchByBrandOrDescriptionContains(query: string): Promise<Product[]> {
    if (!query?.trim() || query.trim().length <= 3) return []

    const searchPattern = `%${query.trim()}%`;
    
    return this.productRepository
      .createQueryBuilder('product')
      .where('product.brand ILIKE :pattern OR product.description ILIKE :pattern', {
        pattern: searchPattern,
      })
      .getMany();
  }
}
```

### 5.3 ProductsModule Configurado ‚úÖ
**Archivo: `src/modules/products/products.module.ts`**
```typescript
import { TypeOrmModule } from '@nestjs/typeorm';
import { Module } from '@nestjs/common';

import { ProductsService } from './services/products.service';
import { Product } from './entities/product.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Product])],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}
```

---

## üîç FASE 6: SEARCH MODULE ‚úÖ IMPLEMENTADO

### 6.1 SearchModule Implementado ‚úÖ
**ESTADO**: ‚úÖ M√≥dulo completamente implementado con controlador, servicio y DTOs

### 6.2 DTOs Implementados ‚úÖ
**Archivo: `src/modules/search/dto/search-query.dto.ts`**
```typescript
import { IsString, IsNotEmpty, Length } from 'class-validator';
import { Transform } from 'class-transformer';

export class SearchQueryDto {
  @IsString({ message: 'El t√©rmino de b√∫squeda debe ser una cadena de texto' })
  @IsNotEmpty({ message: 'El t√©rmino de b√∫squeda es requerido' })
  @Length(1, 255, { message: 'El t√©rmino de b√∫squeda debe tener entre 1 y 255 caracteres' })
  @Transform(({ value }) => typeof value === 'string' ? value.trim() : value)
  searchTerm: string;
}
```

**Archivo: `src/modules/search/dto/search-response.dto.ts`**
```typescript
export class ProductItemDto {
  id: number;
  title: string;
  brand: string;
  description: string;
  originalPrice: number;
  finalPrice: number;
  discountPercentage?: number; // Solo presente si hay descuento
}

export class SearchResponseDto {
  query: string;
  isPalindrome: boolean;
  items: ProductItemDto[];
  totalItems: number;
}
```

### 6.3 SearchService Implementado ‚úÖ
**Archivo: `src/modules/search/services/search.service.ts`**
```typescript
import { Injectable } from '@nestjs/common';

import { SearchResponseDto, ProductItemDto } from '../dto/search-response.dto';
import { ProductsService } from '../../products/services/products.service';
import { PalindromeService } from '../../../utils/palindrome.service'
import { Product } from '../../products/entities/product.entity';

@Injectable()
export class SearchService {
  constructor(
    private productsService: ProductsService,
    private palindromeService: PalindromeService,
  ) {}

  async search(query: string): Promise<SearchResponseDto> {
    const trimmedQuery = (query || '').trim();
    
    // Validaci√≥n b√°sica (class-validator maneja lo principal)
    if (!trimmedQuery) {
      return {
        query: '',
        isPalindrome: false,
        items: [],
        totalItems: 0,
      };
    }
    
    const isPalindrome = this.palindromeService.isPalindrome(trimmedQuery);
    
    let products: Product[] = [];

    // 1. Intentar b√∫squeda por t√≠tulo exacto (prevalece)
    const exactProduct = await this.productsService.findByExactTitle(trimmedQuery);
    if (exactProduct) {
      products = [exactProduct];
    } else if (trimmedQuery.length > 3) {
      // 2. Si no hay match exacto y query > 3, buscar en brand/description
      products = await this.productsService.searchByBrandOrDescriptionContains(trimmedQuery);
    }
    // 3. Si query <= 3 y no hay match exacto, products queda como []

    // Mapea productos aplicando descuento si es pal√≠ndromo
    const items = products.map(product => this.mapProductToItem(product, isPalindrome));

    return {
      query: trimmedQuery,
      isPalindrome,
      items,
      totalItems: items.length,
    };
  }

  private mapProductToItem(product: Product, isPalindrome: boolean): ProductItemDto {
    const originalPrice = Number(product.price);
    
    if (isPalindrome) {
      const discountPercentage = 50;
      const finalPrice = Math.round(originalPrice * 0.5 * 100) / 100; // Redondeo a 2 decimales
      
      return {
        id: product.id,
        title: product.title,
        brand: product.brand,
        description: product.description,
        originalPrice,
        finalPrice,
        discountPercentage,
      };
    } else {
      return {
        id: product.id,
        title: product.title,
        brand: product.brand,
        description: product.description,
        originalPrice,
        finalPrice: originalPrice,
      };
    }
  }
}
```

### 6.4 SearchController Implementado ‚úÖ
**Archivo: `src/modules/search/controllers/search.controller.ts`**
```typescript
import { Controller, Get, Query, HttpException, HttpStatus, BadRequestException } from '@nestjs/common';

import { SearchResponseDto } from '../dto/search-response.dto';
import { SearchService } from '../services/search.service';
import { SearchQueryDto } from '../dto/search-query.dto';

@Controller('api/products')
export class SearchController {
  constructor(private searchService: SearchService) { }

  @Get('search')
  async search(@Query() queryParams: any): Promise<SearchResponseDto> {
    // Validaci√≥n manual del par√°metro con nombre m√°s claro
    const searchTerm = queryParams.q || queryParams.searchTerm;

    if (!searchTerm) {
      throw new BadRequestException({
        message: 'El par√°metro de b√∫squeda "q" es requerido',
        error: 'Bad Request',
        statusCode: 400,
      });
    }

    // Crear DTO para validaci√≥n adicional si es necesario
    const searchDto = new SearchQueryDto();
    searchDto.searchTerm = searchTerm;

    try {
      return await this.searchService.search(searchDto.searchTerm);
    } catch (error) {
      throw new HttpException(
        {
          message: 'Error interno en la b√∫squeda',
          error: 'Internal Server Error',
          statusCode: 500,
        },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

### 6.5 SearchModule Configurado ‚úÖ
**Archivo: `src/modules/search/search.module.ts`**
```typescript
import { Module } from '@nestjs/common';

import { SearchController } from './controllers/search.controller';
import { ProductsModule } from '../products/products.module';
import { SearchService } from './services/search.service';

@Module({
  imports: [ProductsModule],
  controllers: [SearchController],
  providers: [SearchService],
})
export class SearchModule {}
```

**‚ö†Ô∏è PENDIENTE**: El `PalindromeService` necesita ser registrado en el SearchModule para poder ser inyectado en SearchService.

---

## üöÄ FASE 7: MAIN BOOTSTRAP - PENDIENTE

### 7.1 Configurar AppModule ‚úÖ PARCIALMENTE IMPLEMENTADO
**Archivo: `src/app.module.ts`** - ESTADO ACTUAL:
```typescript
import { ConfigModule } from '@nestjs/config';
import { Module } from '@nestjs/common';

import { DatabaseModule } from './core/database/database.module';
import { validationSchema } from './core/config/config.schema';
import { environments } from './core/config/environments';
import config from './core/config/config.factory';

import { ProductsModule } from './modules/products/products.module';
import { SearchModule } from './modules/search/search.module';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    ConfigModule.forRoot({
      envFilePath: environments[process.env.NODE_ENV] || '.env.dev',
      isGlobal: true,
      load: [config],
      validationSchema: validationSchema,
    }),
    DatabaseModule,
    ProductsModule,
    SearchModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

**‚ö†Ô∏è PENDIENTES**: 
- PalindromeService no est√° registrado globalmente
- SearchModule necesita acceso a PalindromeService

### 7.2 Configurar main.ts ‚ö†Ô∏è SIMPLIFICADO 
**Archivo: `src/main.ts`** - ESTADO ACTUAL:
```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

**‚ö†Ô∏è PENDIENTES**: 
- Auto-seeding no implementado
- CORS no configurado
- Validaci√≥n global no configurada
- Configuraci√≥n din√°mica de puerto no implementada

---

## üê≥ FASE 8: DOCKER & DEPLOY

### 8.1 Crear Dockerfile
**Archivo: `Dockerfile`**
```dockerfile
# Etapa 1: Dependencias
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Etapa 2: Build
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Etapa 3: Producci√≥n
FROM node:20-alpine AS prod
WORKDIR /app
ENV NODE_ENV=production

# Copiar dependencias y build
COPY --from=deps /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/package*.json ./

# Copiar archivo de entorno
COPY .env ./.env

# Exponer puerto
EXPOSE 3000

# Comando de inicio
CMD ["node", "dist/main.js"]
```

### 8.3 Actualizar docker-compose con auto-seeding
**Archivo: `docker-compose.yml`**
```yaml
version: "3.9"

services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: store
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d store"]
      interval: 5s
      timeout: 3s
      retries: 10

  api:
    build: .
    depends_on:
      db:
        condition: service_healthy
    environment:
      PORT: 3000
      DATABASE_URL: postgresql://postgres:postgres@db:5432/store
      CORS_ORIGIN: http://localhost:3001
      AUTO_SEED: "true"  # Habilita auto-seeding para facilitar evaluaci√≥n
    ports:
      - "3000:3000"

volumes:
  pgdata:
```

### 8.4 Eliminar scripts de seeding manuales
**NOTA**: Como implementamos auto-seeding en bootstrap, ya no necesitamos scripts manuales separados. Esto simplifica la evaluaci√≥n a un solo comando: `docker compose up --build`

---

## ‚úÖ FASE 9: TESTING & VALIDACI√ìN

### 9.1 Casos de Prueba Manuales
```bash
# Levantar servicios (auto-seeding incluido)
docker compose up --build

# Esperar a ver el mensaje: "‚úÖ Auto-seeding completado"
# Luego probar casos espec√≠ficos:

# 1. T√≠tulo exacto con pal√≠ndromo
curl "http://localhost:3000/api/products/search?q=abba"
# Esperado: 1 producto, isPalindrome=true, finalPrice=250, discountPercentage=50

# 2. T√≠tulo exacto case-insensitive
curl "http://localhost:3000/api/products/search?q=ABBA"
# Esperado: 1 producto (mismo que anterior)

# 3. B√∫squeda por brand/description (len > 3)
curl "http://localhost:3000/api/products/search?q=Sports"
# Esperado: productos con "Sports" en brand/description

# 4. Query corta sin match exacto
curl "http://localhost:3000/api/products/search?q=ab"
# Esperado: items=[], isPalindrome=false, totalItems=0

# 5. Pal√≠ndromo en b√∫squeda contains
curl "http://localhost:3000/api/products/search?q=abba"
# Esperado: products con "abba" en brand/description, 50% descuento

# 6. Error de validaci√≥n
curl "http://localhost:3000/api/products/search"
# Esperado: 400 Bad Request

# 7. Query vac√≠a
curl "http://localhost:3000/api/products/search?q="
# Esperado: 200 OK con items=[]
```

### 9.2 Estructura Final Actual del Proyecto ‚úÖ
```
palindrome-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.factory.ts        ‚úÖ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.schema.ts         ‚úÖ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ environments.ts          ‚úÖ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ database.module.ts       ‚úÖ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ seeds/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ products.seeds.ts    ‚úÖ
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ seed.ts              ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ product.entity.ts    ‚úÖ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products.service.ts  ‚úÖ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products.module.ts       ‚úÖ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ search/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ search.controller.ts ‚úÖ
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ search-query.dto.ts  ‚úÖ
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ search-response.dto.ts ‚úÖ
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ search.service.ts    ‚úÖ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ search.module.ts         ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ palindrome.service.ts        ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts                    ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ main.ts                          ‚ö†Ô∏è PENDIENTE
‚îú‚îÄ‚îÄ .env.dev                             ‚úÖ
‚îú‚îÄ‚îÄ package.json                         ‚úÖ
‚îî‚îÄ‚îÄ tsconfig.json                        ‚úÖ
```

## üìã ESTADO ACTUAL DE IMPLEMENTACI√ìN

### ‚úÖ COMPLETADO (FASES 1-6):
- ‚úÖ Proyecto NestJS con dependencias necesarias
- ‚úÖ Configuraci√≥n centralizada con factory pattern + Joi validation  
- ‚úÖ Database module con TypeORM y Product entity
- ‚úÖ Seeds de productos extensos (100+ productos)
- ‚úÖ PalindromeService funcional
- ‚úÖ ProductsService con b√∫squedas exactas y contains
- ‚úÖ SearchService con l√≥gica de descuentos
- ‚úÖ SearchController con manejo de errores
- ‚úÖ DTOs con validaci√≥n class-validator

### ‚ö†Ô∏è PENDIENTE (FASE 7):
- ‚ö†Ô∏è **PalindromeService registration**: Needs to be available in SearchModule
- ‚ö†Ô∏è **Main.ts enhancement**: Auto-seeding, CORS, validation pipes
- ‚ö†Ô∏è **Environment-based configuration**: Using config factory properly
- ‚ö†Ô∏è **Docker setup**: Dockerfile and docker-compose.yml

### üö´ NO IMPLEMENTADO (FASE 8+):
- üö´ Docker & Deploy (Dockerfile, docker-compose.yml)
- üö´ Testing & Validaci√≥n completa

---

## üéØ CRITERIOS DE ACEPTACI√ìN

- ‚úÖ GET `/api/products/search?q=<t√≠tulo exacto>` ‚Üí un producto (200)
- ‚úÖ GET `/api/products/search?q=<cadena>` con len > 3 ‚Üí productos que contengan q
- ‚úÖ Pal√≠ndromo ‚Üí finalPrice = price * 0.5, con originalPrice y discountPercentage
- ‚úÖ Query len <= 3 sin match exacto ‚Üí items: []
- ‚úÖ Query faltante ‚Üí 400 Bad Request con mensaje descriptivo
- ‚úÖ B√∫squeda case-insensitive para mejor UX
- ‚úÖ Auto-seeding en bootstrap (un solo comando para evaluar)
- ‚úÖ No mutaci√≥n de price en BD
- ‚úÖ Docker compose funcional con seeds autom√°ticas
- ‚úÖ Validaci√≥n robusta con class-validator
- ‚úÖ Manejo completo de errores HTTP
- ‚úÖ Respuesta enriquecida con informaci√≥n de descuento

---

## üìö NOTAS IMPORTANTES

1. **Prevalencia de b√∫squeda**: T√≠tulo exacto SIEMPRE prevalece sobre contains
2. **Normalizaci√≥n**: Solo para pal√≠ndromos, NO para b√∫squeda
3. **Respuestas HTTP**: 
   - 200 para b√∫squedas v√°lidas (con/sin resultados)
   - 400 para par√°metros faltantes/inv√°lidos
   - 500 para errores internos
4. **Redondeo**: Math.round(price * 0.5 * 100) / 100 para 2 decimales
5. **Case sensitivity**: LOWER() para t√≠tulo exacto (mejor UX)
6. **Auto-seeding**: Habilitado por defecto en Docker para facilitar evaluaci√≥n
7. **Naming**: Usar `q` en query param para compatibilidad, `searchTerm` internamente
8. **UX mejorada**: Mostrar originalPrice, finalPrice y discountPercentage expl√≠citamente

## üöÄ COMANDO √öNICO PARA EVALUACI√ìN

```bash
cd "/Users/arnold/Documents/Proyectos/Acueducto/Reto Palindromo/back/palindrome-api"
docker compose up --build
```

Esto ejecutar√°:
1. ‚úÖ Build de la aplicaci√≥n
2. ‚úÖ Levantamiento de Postgres
3. ‚úÖ Auto-seeding de datos de prueba
4. ‚úÖ API lista en http://localhost:3000

**Endpoint de prueba inmediata**: `http://localhost:3000/api/products/search?q=abba`